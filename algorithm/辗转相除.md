题目：写一段代码，求两个整数的最大公约数。要求方法传入两个正整形参数，返回值就是它们的最大公约数，尽可能保证性能。

解法一：暴力枚举

此处就具体实现

解法二：辗转相除法，即欧几里得算法，古希腊数学家欧几里得的发明。

辗转相除法， 又名欧几里得算法（Euclidean algorithm），目的是求出两个正整数的最大公约数。它是已知最古老的算法， 其可追溯至公元前300年前。

欧几里得算法定理：**两个正整数a和b(a>b)，它们的最大公约数等于a除以b的余数c和b之间的最大公约数。**比如，10和25，25除以10商2余5，那么10和25的最大公约数，等同于10和5的最大公约数。

基于这条定理，求出最大公约数就简单了。我们可以使用递归的方法使问题逐步简化。

首先，我们先计算出a除以b的余数c，把问题转化为计算b和c的最大公约数；然后计算b除以c的余数d，把问题转化为计算c和d的最大公约数；再计算出c除以d的余数e，把问题转化为计算d和e的最大公约数……

以此类推，逐渐把两个较大整数之间的运算简化成两个较小整数之间的运算，直到两个数之间可以整除，或者其中一个数减小到1为止。

代码实现

```java
//方法入口
public static int getGreatestCommonDivisor(int numberA, int numberB) {
    int result = 1;
    if (numberA > numberB)
        result = gcd(numberA, numberB);
    else 
        result = gcd(numberB, numberA);
}
//递归方法计算最大公约数
public static int gcd(int a, int b) {
    if (a % b) == 0
        return b;
    else
        return gcd(b, a%b);
}
```

以上的递归算法存在的问题

- 当a和b两个整数笔记大时，a%b取模运算的性能会比较低；

此时，更相减损术登场了。更相减损术，出自于我国古代的《九章算术》，也是一种求解最大公约数的方法。

原理：**两个正整数a和b(a>b)，它们的最大公约数等于a-b的差值c和较小数b之间的最大公约数。**比如10和25，25减去10的差是15，那么10和25的最大公约数等同于15和10的最大公约数。

由此，我们同样可以通过递归来简化问题。首先，计算出a和b的差值c(假设a>b)，把问题转化成计算b和c的最大公约数；然后计算b和c的差值d(假设b>c)，把问题转化成计算c和d的最大公约数；再计算c和d的差值e(假设c>d)，把问题转化成计算d和e的最大公约数…

以此类推，逐渐把两个较大整数之间的运算转化成两个较小整数之间的运算，直到两个数可以相等为止，最大公约数就是最后相等的两个数。

代码实现：

```java
public static int gcd(int a, int b) {
    if (a == b) return a;
    if (a > b) 
        return gcd(b, a-b);
    else
        return gcd(a, b-a);
}
```

这样，使用更相减损术，我们避免了较大整数取模运算性能较低的问题。

但是，更相减损术依靠两数求差值的方式来递归，运算的次数远远大于辗转相除法的取模方法…比如10000和1，就要递归9999次。

下面，我们把辗转相除法和更相减损术的优势结合起来，在更相减损术的基础之上使用移位运算。

众所周知，移位运算的性能非常好。对于给定的正整数a和b，不难得出以下结论。其中gcd(a,b)的意思是a,b的最大公约数函数：

当a和b均为偶数，gcd(a,b) = 2 x gcd(a/2, b/2) = 2 x gcd(a>>1, b>>1)

当a为偶数，b为奇数，gcd(a,b) = gcd(a/2, b) = gcd(a>>1, b)

当a为奇数，b为偶数，gcd(a,b) = gcd(a, b/2) = gcd(a, b>>1)

当a和b均为奇数，利用更相减损术运算一次，gcd(a,b) = gcd(a-b, b)，此时a-b必然是偶数，又可以继续j进行移位运算。

比如10和25的最大公约数的计算步骤如下：

1. 偶数10通过移位，可以转换成求5和25的最大公约数；
2. 利用更相减损术，计算出25-5=20，转换成5和20的最大公约数；
3. 偶数20通过移位，可以转换成5和10的最大公约数；
4. 偶数10通过移位，可以转换成5和5的最大公约数；
5. 利用更相减损术，因为两数相等，所以最大公约数为5；

在两数比较小的时候，暂时看不出计算次数的优势，当两数越大，计算次数的节省就越明显。

代码实现：

```java
public static int gcd(int a, int b) {
    if (a == b)
        return a;
    if (a < b)
        return gcd(b, a);
    else {
        //和1做按位与运算，判断奇偶
        if (!a&1 && !b&1)
            return gcd(a>>1, b>>1);
        else if (!a&1 && b&1)
            return gcd(a>>1, b);
        else if (a&1 && !b&1)
            return gcd(a, b>>1);
        else
            return gcd(a-b, b);
    }
}
```

最后总结一下上述所有解法的时间复杂度：

1.**暴力枚举法**：时间复杂度是O(min(a, b)))

2.**辗转相除法**：时间复杂度不太好计算，可以近似为O(log(max(a, b)))，但是取模运算性能较差。

3.**更相减损术**：避免了取模运算，但是算法性能不稳定，最坏时间复杂度为O(max(a, b)))

4.**更相减损术与移位结合**：不但避免了取模运算，而且算法性能稳定，时间复杂度为O(log(max(a, b)))

