### 如何基于链表实现 LRU 缓存淘汰算法？

思路是这样的：维护一个有序单链表，越靠近链表尾部的节点越是更早之前访问的。当有一个新的数据被访问时，我们从链表头部开始顺序遍历链表。

1. 如果此数据在之前已经被缓存到链表中了，我们遍历得到这个数据对应的节点，并将其从原来的位置删除，然后插入到链表的头部。
2. 如果此数据没有在缓存链表中，又可以分为两种情况：
   * 如果此时缓存未满，则将此节点直接插入到链表头部；
   * 如果此时缓存已满，则删除链表尾节点，将新的数据插入到链表的头部；

算法的时间复杂度：因为不管链表有没有满，我们都需要遍历一遍链表。所以基于链表的实现思路，缓存访问的时间复杂度为O(n)。

优化思路：可以引入散列表（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到O(1)。



### 如何基于数组实现 LRU 缓存淘汰算法？

思路是这样的：维护一个大小固定的一维数组保存缓存数据，越靠近头部的越是更早时间被访问的。当有一个新的数据被访问时，我们从尾部开始遍历数组。

1. 如果此数据在之前已经被缓存到数组中了，我们遍历得到这个数据对应的元素，并将其与数组尾部的元素互换位置。
2. 如果此数据没有缓存在数组中，又可以分为两种情况：
   * 如果此时缓存未满，则将此数据直接记录到数组尾部；
   * 如果此时缓存已满，则将数组头尾元素互换位置，然后将数组尾部元素替换为新的数据；



### 如何判断一个字符串是否是回文字符串？如果字符串是通过单链表来存储的，那该如何判断一个回文字符串呢？相应的时间复杂度又是多少呢？

思路：

1. 使用快慢两个指针遍历单链表，找到字符串的中点。这分两种情况，字符串长度为奇数或偶数。慢指针倒序记录前一半字符串，即单链表逆序。
2. 同时遍历逆序的单链表前半段，以及慢指针继续顺序遍历单链表的后半段，比较两个单链表是否相同。

时间复杂度分析：寻找单链表中点和单链表前半段逆序操作的时间复杂度为O(n/2)，比较回文字符串的时间复杂度为O(n/2)，总的时间复杂度就是O(n)。



