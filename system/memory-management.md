### 操作系统-内存管理

#### 概念

内存管理，就是讨论操作系统怎样创建存储器抽象模型以及怎样管理它们。

**分层存储体系**

**存储管理器** - 操作系统中管理分层存储体系的的部分。它的作用是有效的管理内存，即记录哪些内存是正在使用的，哪些内存是空闲的；在进程需要时为其分配内存，在进程使用完后释放内存。

#### 存储器抽象

##### 无存储器抽象

每一个程序都是直接访问物理内存。

在这种情况下，同时运行两个程序是不可能的。如果第一个程序在2000位置写入一个新的值，就会擦掉第二个程序在相同位置上的所有内容，所以同时运行两个程序，会导致这两个程序立刻崩溃。

在没有存储器抽象的系统中实现并行的一种方法是使用多线程来编程，因为一个进程中的所有线程对同一内存映像都可见。但多线程并不能实现不同程序的并行。

那么在没有存储器抽象的系统中就不能同时运行多个程序了吗？

还是有办法的。操作系统只需要把当前内存中的所有内容保存到磁盘文件中，然后把下一个程序读入到内存中再运行即可。只要在同一时间内存中只有一个程序，那么就不会发生冲突。即使用交换。

另外，在特殊硬件的帮助下，即使没有交换功能，并发的运行多个程序也是可能的。IBM360使用4位的保护键（存储在cpu的特殊寄存器中），内存被划分为2K的块，每个块被分配一个4位的保护键。一个运行中程序如果访问的保护键与其PSW（程序状态字）中存有的4位码不同，360的硬件会捕获到这一事件。因为只有操作系统可以修改保护键，这样就可以防止用户进程之间、用户进程和操作系统之间的互相干扰。此外，该中方法还需要使用**静态重定位**技术加以改进。

##### 一种存储器抽象：地址空间

###### 地址空间的概念

要使多个应用程序同时处于内存中并且不互相影响，需要解决两个问题：保护和重定位。

就像进程的概念创建了一类抽象从CPU以运行程序一样，地址空间为程序创造了一种抽象的内存。**地址空间**是一个进程可以用于寻址的内存的一套地址集合。每个进程的都有一个自己的地址空间，并且这个地址空间独立于其他进程的地址空间（除了在一些特殊情况下进程需要共享它们的地址空间外）。

###### 使用基址寄存器和界限寄存器

该办法的思想是使用**动态重定位**，简单的把每个进程的地址空间映射到物理内存的不同部分。经典办法是给每个CPU配置两个特殊的硬件寄存器，通常叫做**基址寄存器**和**界限寄存器**。当一个程序运行时，程序的起始物理地址装载到基址寄存器中，程序的长度装载到界限寄存器中。（注：基址寄存器就是用来动态重定位的）

![Multiple+Programs+Without+Memory+Abstraction_+Drawback](E:\git\engineer\system\mos\Multiple+Programs+Without+Memory+Abstraction_+Drawback.jpg)

该办法的缺点是，每次访问内存都需要进行加法和比较运算。比较运算可以做得很快，但是加法运算由于进位传递时间的问题，在没有使用特殊电路的情况下会显得很慢。

###### 交换技术

如果计算机的物理内存足够大，可以保存所有进程，那么之前提及的方法都或多或少是可行的。但实际上，所有进程所需的RAM数量总和通常都要远远超出存储器能够支持的范围。

有两种支持内存超载的通用方法。最简单的策略是**交换**（swapping）技术，即把一个进程完整的调入内存，使该进程运行一段时间，然后把它存回磁盘。空闲进程主要存储在磁盘上，所以当它们不运行时就不占用内存。另一种策略是**虚拟内存**（virtual memory），下一节会详细讨论。

交换在内存中产生了多个空闲区（hole，也成为空洞），通过把所有进程尽可能向下移动，有可能将这些小的空闲区合成一大块。该技术成为**内存紧缩**（memory compaction）。

进程的换入换出见下图：

![Swapping+(1)+Figure+3-4.+Memory+allocation+changes+as+processes+come+into+memory+and+leave+it.+The+shaded+regions+are+unused+memory.](E:\git\engineer\system\mos\Swapping+(1)+Figure+3-4.+Memory+allocation+changes+as+processes+come+into+memory+and+leave+it.+The+shaded+regions+are+unused+memory..jpg)

为进程可能增长的数据段和堆栈段预留空间见书中下图：

![Swapping+(2)+Figure+3-5.+(a)+Allocating+space+for+a+growing+data+segment.+(b)+Allocating+space+for+a+growing+stack+and+a+growing+data+segment.](E:\git\engineer\system\mos\Swapping+(2)+Figure+3-5.+(a)+Allocating+space+for+a+growing+data+segment.+(b)+Allocating+space+for+a+growing+stack+and+a+growing+data+segment..jpg)

空闲内存管理——位图和空闲区链表两种方法

使用位图方法时，内存可能被划分成小到几个字或大到几千字节的分配单元。每个分配单元对应于位图中的一位，0表示空闲，1表示占用（或者相反）。如下图所示：

![slide_7](E:\git\engineer\system\mos\slide_7.jpg)

另一种记录内存使用情况的方法是，维护一个记录已分配内存段和空闲内存段的链表。其中链表中的一个节点或者包含一个进程，或者是两个进程间的一块空闲区。可以用图3-6(c)所示的段链表来表示图3-6(a)所示的内存布局。链表中的每一个节点都包含以下域：空闲区(H)或进程(P)的指示标志、起始地址、长度和指向下一个节点的指针。

当按照地址顺序在链表中存放进程和空闲区时，有以下几种算法可以为创建的进程分配内存：

- 首次适配算法(first fit)
- 下次适配算法(next fit)
- 最佳适配算法(best fit)
- 最差适配算法(worst fit)
- 快速适配算法(quick fit)

##### 虚拟内存

###### 概念

虚拟内存的基本思想是：每个程序拥有自己的地址空间，这个空间被分割成多个块，每一块称作一**页**或**页面**(page)。每一页有连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。

###### 分页(paging)

有程序产生的这些地址成为**虚拟地址**(virtual address)，它们构成了一个**虚拟地址空间**(virtual address space)。在没有虚拟内存的计算机上，系统直接将虚拟地址送到内存总线上，读写操作使用具有同样地址的物理内存字；而在使用虚拟内存的情况下，虚拟地址不是被直接送到内存总线上，而是被送到**内存管理单元**(Memory Management Unit，MMU)，MMU把虚拟地址映射为物理地址，如图3-8所示。

![Paging+(1)](E:\git\engineer\system\mos\Paging+(1).jpg)

图3-9所示的简单例子说明了这种映射是如何工作的。在这个例子中，有一台可以产生16位地址的计算机，地址范围从0到64K-1，且这些地址是虚拟地址。然而，这台计算机只有32KB的物理内存，因此，虽然可以编写64KB的程序，但它们却不能被完全调入内存运行。在磁盘上必须有一个最多64KB的程序核心映像的副本，以保证程序片段在需要时能被调入内存。

![Paging+(2)+Figure+3-9.+Relation+between+virtual+addresses+and+physical+memory+addresses+given+by+page+table.](E:\git\engineer\system\mos\Paging+(2)+Figure+3-9.+Relation+between+virtual+addresses+and+physical+memory+addresses+given+by+page+table..jpg)

**页面**(page)——虚拟地址空间按照固定大小划分成的若干单元。

**页框**(page frame)——页面在物理内存中对于的单元。

**缺页中断**或**缺页错误**(page fault)——当程序访问一个未映射的页面，MMU注意到该页面没有被映射，于是使CPU陷入操作系统，这个陷阱就叫做缺页中断或缺页错误。

MMU内部结构如图3-10，输入的虚拟地址为8196(二进制是0010000000000100)，输入的16位虚拟地址被分为4位的页号和12位的偏移量。4位页号可以表示16个页面，12位偏移量可以为一页内的全部4096个字节编址。可用页号作为页表(page table)的索引，以得出对应于该虚拟地址页面的页框号。如果“在/不在”位是0，则将引起一个操作系统陷阱。如果该位为1，则将在页表中查到的页框号复制到输出寄存器的高3位中，再加上输入虚拟地址中的低12位偏移量。如此就构成了15位的物理地址。输出寄存器的内容随即被作为物理地址送到内存总线。

![Paging+(3)+Figure+The+internal+operation+of+the+MMU+with+16+4-KB+pages.](E:\git\engineer\system\mos\Paging+(3)+Figure+The+internal+operation+of+the+MMU+with+16+4-KB+pages..jpg)

###### 页表

页表的目的是把虚拟页面映射成页框。从数学的角度说，页表是一个函数，它的参数是虚拟页号，结果是物理页框号。通过这个函数可以把虚拟地址中的虚拟页面域替换成页框域，从而形成物理地址。

###### 加速分页过程

- 转换检测缓冲区——使用小型硬件设备TLB

  ![Multilevel+Page+Tables](E:\git\engineer\system\mos\Multilevel+Page+Tables.jpg)

- 软件TLB管理

###### 针对大内存的页表

- 多级页表
- 倒排页表

##### 页面置换算法

###### 最优页面置换算法

###### 最近未使用页面置换算法

###### 先进先出页面置换算法

###### 第二次机会页面置换算法

###### 时钟页面置换算法

###### 最近最少使用页面置换算法

###### 用软件模拟LRU

###### 工作集页面置换算法

###### 工作集时钟页面置换算法

###### 页面置换算法小结

##### 

#### 分页系统中的设计问题

#### 有关实现的问题

#### 分段







